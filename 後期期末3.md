# 回路設計論 2019/1/9 ~ 23
### 研究室説明
- ネットワークがらみ
  - 聴覚補助(デジタル補聴器)システムの開発
  - 設備はそろっている(?)
- 人間の特性、ヒューマンインタフェース
  - VR、バーチャル空間で遠隔でロボットを操作する際に反力をネットワークを通して再現。
  - 触覚: 表面の粗さによりどの位凹凸ならば人間が理解できるか
  - VR空間上で音の変化
- 主に人間の認識を調べる研究室?
- 膨大な実験データを得てまとめる
# 1. コンピュータ概論
## 1.1 序論
## 1.2 コンピュータの構成
## 1.3 情報の表現とCPUのビット数
## 1.4 プログラミング言語
## 1.5 マイクロコンピュータの回路構成

### コンピュータの基本構造 (5大機能)
![1-001](https://github.com/tmorio/CircleClass/blob/Photo/img001.PNG?raw=true "10")  
これらを実現するには以下の回路構成を取る。  
**ここに画像**  
CPUはメモリやI/Oポートに**アクセス**と呼ばれる、データの読み書きを行いながら逐次プログラムを実行する。  
- CPUがデータの読み込みを行う場合
  - 何にアクセスするか示す、アドレス信号を出力してデータを待つ
- CPUがデータの書き出しを行う場合
  - アドレス信号を出力しながらデータ信号を出力

これらは回路効率化するために、**アドレスバス**、**データバス**と呼ぶ**共通の信号線**で接続。  
<br>
複数メモリ、ポートが存在する場合、アドレスが重複しないよう**アドレスデコーダ**と呼ばれる回路を経由させる。  

## 1.6 CPUの内部構造
一般的なCPUの内部構造を以下に示す。  
**ここに画像**  
- レジスタ
  - CPU内部の小さなメモリ
- アドレスレジスタ, データレジスタ
  - アドレス信号やデータ信号を扱うレジスタ
- 命令レジスタ
  - 読み込んだ命令を解析するための記憶装置
- プログラムカウンタ
  - 次に実行するプログラム上のメモリ番地を示す
- アキュムレーター
  - 演算に用いるレジスタ
- ALU
  - 算術・論理演算装置
  - 入力されたデータは算術演算、論理演算処理させて出力
  
### CPUの動作順序
1. **フェッチ**と呼ばれる命令の読み込み動作  
2. プログラムカウンタの内容がアドレスレジスタに転送される  
3. アドレス信号がアドレスバスに出力  
4. データバスから入力されたデータが、データレジスタを介して命令レジスタに転送  
5. 命令デコーダで解析  

<br/>

### 命令の実行
- 制御回路
  - 解析された命令に、事前に割り当てられた動作手順通りに制御
  - 制御回路はALU間のデータ転送、演算をする
- 演算処理
  - アキュムレーターを介して実行
  - アキュムレーターの内容と他レジスタの内容がALUに入力
  - ALUが演算を行い、アキュムレーターに結果を記憶
  - 乗除算を行う場合は演算結果を使って演算するため、小規模コンピュータではアキュムレーターを用いた構造が有利
  
## 1.7 フェッチサイクルと実行サイクル
コンピュータはクロックパルスに同期して動作  
命令の実行は、命令の読み出しと実行の繰り返しで行う。  
命令の実行に必要なサイクル → **命令サイクル**  
<br>
マシンサイクルは次のサブサイクルより成り立つ。  
- フェッチサイクル
  - CPUは命令のあるアドレスをアドレスバス経由でメモリに転送
  - アドレスによりメモリの番地が選択
  - 命令がメモリからデータバスを介しCPUに読み出し
- 実行サイクル
  - 命令はCPUで解読・命令で設定された操作の実行

次に典型的なマシンサイクルを示す。  
**ここに画像**  

## 1.8 アーキテクチャ
### アーキテクチャ is 何
→ CPUの設計方法
### アーキテクチャの大まかな種類
- CISC (Conplex Instruction Set Computer)
  - 多種多様な命令がある
  - 効率の良いプログラムの作成が可能
  - ハードウェアは複雑
- RISC (Reduced Instruction Set Computer)
  - 命令数は少ない
  - 複雑な処理 → 複雑なプログラム
  - ハードウェアは単純
- 現在では双方の利点を生かし、欠点を補ったCPUの設計が主流

# 2. K-COMシミュレーターの構成
## 2.1 なにこれ
コンピュータの構造を理解するために、最小限の規模で動作するコンピュータの動作シミュレーター  
[K-COM マイコンの仕組みの学習用教材](http://www.vector.co.jp/soft/win95/edu/se178902.html)  

<br />

### K-COMの仕様
- 扱う数は整数のみ
- 簡単な加減乗除算ができる
- データ長1 byte (=8 bit)
- 0 ~ 255 (-128 ~ 127)までの整数値を扱える
- 直接使用できるレジスタはアキュムレーターのみ
- 演算はアキュムレーター+メモリ内容での演算のみ
- プログラムカウンタ、命令レジスタなどの最小限構成
- 1 byteを上位3 bitと下位5 bitに分けて、それぞれ命令コード、番地指定(オペランド)に使用
- 命令は最大8個、番地は0~31番地
- メモリレジスタ間の転送命令、算術演算命令、ビット演算命令、条件ジャンプ命令のみの構成
- I/O命令はなし
- マップドI/O方式
  - メモリにマッピングされた番地に書き込み、読み込みで外部装置との入出力
  
## 2.2 命令構成
K-COMで使用できる命令  
- ADD命令 (加算)
- SUB命令 (減算)
- NAND命令 (論理演算命令)
- SHIFT命令 (論理演算命令)
- LD命令 (転送命令)
- ST命令 (転送命令)
- JPC命令 (ジャンプ命令)
- JPZ命令 (ジャンプ命令)

※実行停止命令(HALT)はJPZ命令のアドレス部分がすべて1FH番地にジャンプするときに回路内で検出&停止、命令コードを2進数で000 ~ 111までを順で割り振り  
演算、転送命令はアキュムレーターとメモリ間で行われる。  

## 2.3 機械語
- データ長8 bit中、上位3 bit、下位5 bitをアドレスまたは数値として構成  
- 命令数は2^3 = 8、メモリ空間 2^5 = 32 byte  
- 演算はアキュムレーターとメモリを介して実行  
- 8 bitの定数値0 ~ 255(-128 ~ 127)まで利用可能

### アセンブリ言語 ADD 0FHの機械語生成の例
1. ADDは命令コード、0FHは番地指定  
2. ADDの命令コードは000と定義されている  
3. オペランドはメモリ上のアドレスを示し、16進数0FHを5 bitの2進数へ(01111)  
4. これらを並べて8 bitの2進数とし機械語となる  

## 2.4 メモリ、I/Oマップ
マップドI/O方式のため、利用できるメモリ領域は0 ~ 1DH番地  
1EH番地は入力ポート、1FH番地は出力ポートに対応させる  
メモリからデータを読み込むと同様に、ロード命令(LD)によって1EH番地からデータが読める。実際は入力ポートからデータが入力。  
同様にストア命令(ST)により、1FH番地に書き込み、出力ポートに出力される。  

# 3. K-COMの回路構成
## 3.1 K-COMの回路構成
- 一般的な構成
  - CPU
  - メモリ
  - 入出力ポート
  - いくつかのLSI
- K-COM
  - メモリ、入出力ポートをLSI内部に持つ
  - アドレス信号は内部アドレスバスに介して、直接的に内部メモリ、入出力ポートに伝わる
  - データバスも内部にあつ
  - 内部データバスを介し、メモリ、アキュムレーター間のデータ転送、メモリとALUを直接接続により演算
  
## 3.2 レジスタ
1 bitのD-FFを8個並べて同時に読み書き可能な回路  
入出力端子は干渉しないように、トライステートバッファ(**三状態**)でデータバスに接続  

## 3.3 ALUとアキュムレータ
1. アキュムレータとメモリから8 bitのデータをALUに入力、演算結果をアキュムレータへ  
2. ALUは入力8 bit x2+制御信号、出力8 bit + フラグを持った組み合わせ回路  

<br/>

実際は一旦にALUの出力に保持された後、アキュムレータに格納。  
演算方法は制御信号で決定。  
演算結果はステータスフラグで表示  

## 3.4 メモリ

- ROM (Read Only Memory)
  - 読み出し専用
  - アドレス信号でデータの読み出し
  - 制御信号はROM動作用の、イネーブル信号と読み出しのリードのみ
- RAM (Ramdom Access Memory)
  - 読み書き可能
  - アドレス信号により読み書き
  - 制御信号はRAM動作用の、イネーブル信号と読み書きを指定する制御信号
  
<br />
メモリセル8個で1 byteのデータを表し、マトリクス上に配置。  
入力されたアドレスは出コード&対応する番地のメモリセルを有効化し、並列にアクセス。  
- RAM
  - メモリセルはフリップフロップなどの記憶素子から成り、読み出し、書き込みの信号線がある。  
- ROM
  - 0か1の固定出力を得るダイオードやトランジスタを用いた結線回路
  
## 3.5 制御構造
### 制御構造 is 何
命令の各段階での天順を決定し、レジスタ、メモリ、ALUなどの各回路の入手力ゲートを制御するタイミング信号を生成する順序回路を指す。  
従って、基本的には順序回路とする。  
ここではマイクロプログラム制御方式を扱う。  
<br>

- 構成
  - 制御論理回路
  - ステータスレジスタ
  - マイクロコードROM
    - 各命令の制御手順を記憶するROM
    - 出力が制御信号となり、各回路の入出力ゲートの制御信号となる
    
#### マイクロプログラミングとは?

機械命令 (基本的な動作 「マイクロ命令」と呼ばれる)
1. 命令の読み出し
2. 命令の解釈
3. 命令の実行

#### 3.をより細かく

3.1 オペランド - (命令の目的語)のアドレス計算  
3.2 オペランド - データの読み出し  
3.3 ALUの演算  
3.4 演算結果の格納  
4.1 次に実行すべき命令のアドレス指定 (プログラムカウンタの更新)  
<br />
動作 -> 詳細な基本動作に分解  
<br />
#### コンピュータの基本設計
基本操作 = **マイクロ命令**  
-> これらを組み合わせて、内部の動作などに組み立てる。  
**操作系列 (命令系列)** がマイクロプログラム  
↓  
マイクロプログラム制御式  
<br/>
### 布線論理 (Wired Logic)
1. 実際にマイクロプログラムを使用して、**順序制御回路を設計**
2. それを内蔵した制御装置を用いて、**CPUを構成**
3. その場合、一般のプログラムがデータ処理を行うのに対して、マイクロプログラム制御式では、**コンピュータのハードウェアを直接マイクロプログラムで制御**
4. メモリに格納されている**プログラム**を実行することになる  

#### IBM
システム/360  
大型機 -> 小型機までの系列  
アーキテクチャ上の互換性を持たせるために利用された。  

#### マイクロプログラム制御方式の分類
- 水平型マイクロ命令
    - 制御論理記述向き
- 垂直型マイクロ命令
    - アルゴリズム記述向き

<br />

- 水平型マイクロ命令 (制御論理記述向き)
    - 直接制御方式
        - マイクロ命令の各ビットが処理装置内のゲートなどの制御ポイントと1対1に対応
    - 間接制御方式 (符号化制御方式)
        - マイクロ命令のビット数を低減するため符号化してビット数を減らす

<br/>
制御論理回路では、上位3 bitの命令コード、フラグ、マイクロコードROMが入力され、クロックに同期して、次の状態がステータスレジスタに出力される。  
ステータスレジスタの値はデコードさえ、マイクロコードROM内に記憶された制御信号が各回路の入出六ゲートに送られる。  

## 3.6 I/Oポート
### なにこれ
- 入力ポートは、外部入力装置からの入力信号を、バッファを通して信号レベルをHigh、Lowのいずれかにして、トライステートバッファに加えられたI/Oデコーダ信号に同期して、データを取り込む。  
- 出力ポートは、トライステートバッファに加えられたI/Oデコーダの信号に同期して、データをD-FFに書き込む構造。D-FFから常にHigh、Lowの信号が出力されているので、外部装置は、独自のタイミングで信号を受け取れる。
